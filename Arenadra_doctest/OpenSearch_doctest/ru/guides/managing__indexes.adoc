:doc-name: Managing indexes
:toc:
:toc-title: Table of contents
:toclevels: 3
:table-caption: Table
:imagesdir: guides/images
:figure-caption: Image
:figure-number: 0
:source-highlighter: highlight.js
:relfilesuffix: .adoc

// Основные предложения по улучшению инструкции: 
// 1. Структурировать тест с помощью нумерованных списков. Нумерация действий позволит читателю понять последовательность действий. 
// 2. Подробнее объяснять параметры в приведенных примерах: рассказывать, что конкретно каждый из параметров делает. И использовать для этого маркированные списки. 
// 3. Всегда следить за подзаголовками и их расположением. Если, например, в этом случае после заголовка второго уровня идет единственный подзаголовок третьего уровня "Пример ответа", то этот подзаголовок следует исключить. 
// Заключение: В инструкции очень много объяснений, однако они не структурированы и их сложно воспринимать. Часто смешивается одно описание действий со следующим. При общей большой описательной части, часть терминологии не объясняется и нет ссылок на документы, где можно получить о ней представление. 

= Управление индексами

Индексация данных в OpenSearch осуществляется с помощью REST API.
Для этого предусмотрены два основных интерфейса: `index` API и `_bulk` API.

Если данные поступают постепенно, например, как заказы в интернет-магазине малого бизнеса, рекомендуется использовать `index` API и добавлять документы по мере их появления.
В случаях, когда обновления происходят периодически (например, еженедельные публикации на маркетинговом сайте), удобнее заранее сформировать файл с данными и загрузить его с помощью `_bulk` API.
`_bulk` API позволяет объединять несколько операций в одном запросе, что существенно повышает производительность при массовой индексации документов.
Однако при работе с очень крупными документами рекомендуется выполнять индексацию по одному: так проще избежать превышения лимитов на размер запроса и снизить нагрузку на кластер.

При индексации документа максимальный размер значения поля `_id`, идентификатора документа, не должен превышать 512 байт.

== Введение в индексацию данных в OpenSearch

Прежде чем выполнять поиск, данные необходимо проиндексировать.
Индексация -- это метод структурирования данных для их быстрого и эффективного поиска.
Результатом индексации является структура, которая называется индексом.

В OpenSearch основная единица хранения данных -- это JSON-документ.
В рамках одного индекса каждый документ идентифицируется с помощью уникального идентификатора (ID).

Пример запроса к `index` API:

[source,json]
----
PUT <index>/_doc/<id>
{ "A JSON": "document" }
----

Если используется интерфейс `_bulk` API, то формат запроса будет другой, так как индекс документа и ID указываются в теле запроса:

[source,json]
----
POST _bulk
{ "index": { "_index": "<index>", "_id": "<id>" } }
{ "A JSON": "document" }
----

Формат bulk-данных должен соответствовать определенному формату, в котором необходим символ новой строки (\n) в конце каждой строки, в том числе в последней.
Ниже указан пример базового формата bulk-данных:

[source,text]
----
Action and metadata\n
Optional document\n
Action and metadata\n
Optional document\n
----

[NOTE]
====
Здесь JSON-документ является необязательным, так как для операции `delete` он не требуется.
Однако для прочих операций (`index`, `create`, и `update`) этот документ обязателен.
Если нужно, чтобы операция завершалась ошибкой при попытке создать уже существующий документ, используйте `create` вместо `index`.
====

Чтобы проиндексировать bulk-данные с помощью команды `curl`, перейдите в папку, где сохранен ваш файл, и выполните следующую команду:

[source,bash]
----
curl -H "Content-Type: application/x-ndjson" -POST [https://localhost:9200/data/_bulk](https://localhost:9200/data/_bulk) -u 'admin:admin' --insecure --data-binary "@data.json"
----

Если одна из операций в запросе к `_bulk` API завершится с ошибкой, OpenSearch продолжит выполнение остальных.
Для выявления проблем используйте массив `items` в ответе, так как порядок элементов в нём соответствует порядку операций в запросе.

Также, если в запросе не указан идентификатор (ID), OpenSearch сгенерирует его автоматически.
В следующем примере индекс movies создаётся автоматически, документ индексируется, а уникальный идентификатор генерируется системой:

[source,json]
----
POST movies/_doc
{ "title": "Spirited Away" }
----

Однако у автоматической генерации идентификатора (ID) есть существенный недостаток.
Он заключается в том, что такой документ сложно обновлять в будущем из-за отсутствия фиксированного идентификатора.
Кроме того, если вы выполните такой запрос 10 раз, OpenSearch проиндексирует этот документ как 10 разных документов с уникальными идентификаторами.

Чтобы задать конкретный ID, например 1, используйте следующий запрос (обратите внимание, что используется метод PUT вместо POST):

[source,json]
----
PUT movies/_doc/1
{ "title": "Spirited Away" }
----

Поскольку в этом запросе явно указывается идентификатор, при повторных 10 запросах документ не будет дублируется.
В результате обновится один документ, а значение поля `_version` увеличится до 10.

По умолчанию в индексах используется один primary-шард и один replica-шард.
Чтобы задать другие параметры, создайте индекс перед добавлением документов:

[source,json]
----
PUT more-movies
{ "settings": { "number_of_shards": 6, "number_of_replicas": 2 } }
----

== Ограничения на именование индексов

У индексов OpenSearch есть следующие ограничения на именование:

- Только строчные буквы в имени индекса.
- Имя не может начинаться с нижнего подчеркивания `_` или дефиса `-`.
- В имени недопустимо наличие пробелов, запятых и следующих символов: `:`, `"`, `*`, `+`, `/`, `\`, `|`, `?`, `#`, `>`, `<`.

== Чтение данных

После индексации документа вы можете получить его, отправив GET-запрос на ту же конечную точку, которую вы использовали для индексации:

[source,json]
----

GET movies/_doc/1

{
"_index" : "movies",
"_type" : "_doc",
"_id" : "1",
"_version" : 1,
"_seq_no" : 0,
"_primary_term" : 1,
"found" : true,
"_source" : {
"title" : "Spirited Away"
}
}
----

Документ располагается в объекте `_source`.
Если документ не найден, то ключ `found` будет равен `false`, и не будет поля `_source`.

Чтобы получить несколько документов одной командой, используйте операцию `_mget`.
Ее формат аналогичен операции `_bulk`, однако в теле запроса необходимо указать индекс и идентификатор:

[source,json]
----
GET _mget
{
  "docs": [
    {
      "_index": "<index>",
      "_id": "<id>"
    },
    {
      "_index": "<index>",
      "_id": "<id>"
    }
  ]
}
----

Формат операции `_mget`, чтобы получить только определённые поля:

[source,console]
----
GET _mget
{
  "docs": [
    {
      "_index": "<index>",
      "_id": "<id>",
      "_source": "field1"
    },
    {
      "_index": "<index>",
      "_id": "<id>",
      "_source": "field2"
    }
  ]
}
----

Чтобы проверить наличие документа в системе, используйте следующую команду:

[source,json]
----
HEAD movies/_doc/<doc-id>
----

Если документ существует, в ответе будет код `200 OK`, если нет -- `404 Not Found`.

== Обновление данных

Чтобы обновить существующие поля или добавить новые, отправьте POST-запрос для операции `_update` с изменениями в объекте `doc`:

[source,json]
----
POST movies/_update/1
{
  "doc": {
    "title": "Castle in the Sky",
    "genre": ["Animation", "Fantasy"]
  }
}
----

Обратите внимание на обновленное поле `title` и `genre`:

[source,json]
----
GET movies/_doc/1

{
  "_index" : "movies",
  "_type" : "_doc",
  "_id" : "1",
  "_version" : 2,
  "_seq_no" : 1,
  "_primary_term" : 1,
  "found" : true,
  "_source" : {
    "title" : "Castle in the Sky",
    "genre" : [
      "Animation",
      "Fantasy"
    ]
  }
}
----

У документа также увеличивается значение поля `_version`.
Это поле позволяет отслеживать, сколько раз документ был обновлён.

POST-запросы выполняют частичное обновление документов.
Чтобы полностью заменить документ, используйте PUT-запрос.

[source,json]
----
PUT movies/_doc/1
{
  "title": "Spirited Away"
}
----

Документ с идентификатором 1 будет содержать только поле `title`, так как весь предыдущий документ будет полностью заменён содержимым, переданным в этом PUT-запросе.

Используйте объект `upsert` для условного обновления документов в зависимости от того, существуют ли они уже в системе.
В этом примере, если документ уже существует, его поле title будет обновлено на «Castle in the Sky». 
Если документ отсутствует, OpenSearch создаст его, используя данные из объекта upsert.

[source,json]
----
POST movies/_update/2
{
  "doc": {
    "title": "Castle in the Sky"
  },
  "upsert": {
    "title": "Only Yesterday",
    "genre": ["Animation", "Fantasy"],
    "date": 1993
  }
}
----

=== Пример ответа

[source,json]
----
{
  "_index" : "movies",
  "_type" : "_doc",
  "_id" : "2",
  "_version" : 2,
  "result" : "updated",
  "_shards" : {
    "total" : 2,
    "successful" : 1,
    "failed" : 0
  },
  "_seq_no" : 3,
  "_primary_term" : 1
}
----

Каждая операция обновления документа имеет уникальную комбинацию значений `_seq_no` и `_primary_term`.

Сначала OpenSearch применяет обновления к primary-шарду, а затем распространяет их на все replica-шарды.
В редких случаях может возникнуть ситуация, когда несколько пользователей одновременно обновляют один и тот же документ.
Например, один из пользователей может прочитать документ, расположенный на replica-шарде, и обновить его до того, как на этот шард поступят более свежие данные с primary-шарда.
В результате эта операция обновит только устаревшую версию документа.
В лучшем варианте разрешения этой ситуации оба пользователя внесут в документ одинаковые изменения, и данные останутся корректными.
A в худшем -- документ будет содержать устаревшую информацию.

Чтобы это предотвратить, передавайте значения параметров `_seq_no` и `_primary_term` в заголовке запроса:

[source,json]
----
POST movies/_update/2?if_seq_no=3&if_primary_term=1
{
  "doc": {
    "title": "Castle in the Sky",
    "genre": ["Animation", "Fantasy"]
  }
}
----

Если документ был обновлен после его получения, значения `_seq_no` и `_primary_term` будут отличаться.
Операция обновления завершится с ошибкой **409 - Conflict**.

При использовании `_bulk` API указывайте значения параметров `_seq_no` и `_primary_term` в метаданных операции.

== Удаление данных

Чтобы удалить документ из индекса, используйте запрос с методом DELETE:

[source,json]
----
DELETE movies/_doc/1
----

Операция DELETE увеличивает значение поля `_version`.
Если затем вы добавите документ к тому же идентификатору, значение поля `_version` будет снова увеличено.
Это связано с тем, что при удалении OpenSearch удаляет только содержимое документа,`_source`, но сохраняет его метаданные в индексе.

== Следующие шаги

- Плагин **Index Management (IM)** позволяет автоматизировать повторяющиеся действия по управлению индексами и сократить расходы на хранение.
Подробнее в разделе link:https://docs.opensearch.org/docs/latest/im-plugin/ism/index[Index State Management].

- Инструкции по переиндексации данных -- в разделе link:https://docs.opensearch.org/docs/latest/im-plugin/reindex-data[Переиндексация данных].