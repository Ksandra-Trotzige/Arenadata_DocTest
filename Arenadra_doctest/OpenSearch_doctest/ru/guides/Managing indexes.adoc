:doc-name: Managing indexes
:toc:
:toc-title: Table of contents
:toclevels: 3
:example-caption: Example
:example-number: 0
:table-caption: Table
:imagesdir: guides/images
:figure-caption: Image
:figure-number: 0
:source-highlighter: highlight.js
:relfilesuffix: .adoc

= Управление индексами

Индексация данных производится с помощью REST API OpenSearch. Существуют два API: index API и `_bulk` API.

Если новые данные поступают постепенно (например, как в малом бизнесе поступают заказы от клиентов), можно использовать index API, чтобы добавлять документы по мере их поступления.
Если же обновления происходят реже (например, как в случаях с еженедельными обновлениями на маркетинговом сайте), удобнее заранее сформировать файл и отправить его с помощью `_bulk` API.
Для индексации большого количества документов `_bulk` API группирует запросы, чтобы обеспечить более высокую производительность.
Однако если документы очень объёмные, возможно, их придётся индексировать по-одному.

При индексировании документов размер идентификатора документа `_id` должен быть не более 512 байт.

== Введение в индексацию данных в OpenSearch

Перед поиском по данным, сначала их нужно проиндексировать.
Индексация -- это способ организации данных для их быстрой выборки.
Полученная структура называется индексом.

В OpenSearch основной единицей данных является JSON-документ.
Внутри индекса OpenSearch идентифицирует каждый документ с помощью уникального идентификатора.

Пример запроса к index API:

[source,console]
----
PUT <index>/\_doc/<id>
{ "A JSON": "document" }
----

Если используется `_bulk` API, то формат запроса будет другой, так как индекс и ID указываются в теле запроса:

[source,console]
----
POST \_bulk
{ "index": { "\_index": "<index>", "\_id": "<id>" } }
{ "A JSON": "document" }
----

Формат bulk-данных должен соответствовать определенному формату, в котором необходим символ новой строки (\n) в конце каждой строки, в том числе в последней.
Ниже указан пример базового формата bulk-данных:

[source,text]
----
Action and metadata\n
Optional document\n
Action and metadata\n
Optional document\n
----

[NOTE]
====
JSON-документ не обязателен, потому что операция удаления не требует документа.
Остальные действия (index, create, update) требуют наличия документа. Если вы хотите, чтобы операция завершалась ошибкой при наличии уже существующего документа, используйте действие `create` вместо `index`.
====

Пример команды `curl` для bulk-индексации:

[source,bash]
----
## curl -H "Content-Type: application/x-ndjson" -POST [https://localhost:9200/data/\_bulk](https://localhost:9200/data/_bulk) -u 'admin\:admin' --insecure --data-binary "@data.json
----

Если одна из операций в `_bulk` завершится с ошибкой, OpenSearch продолжит выполнение остальных. Для диагностики используйте массив `items` в ответе — его порядок соответствует порядку действий в запросе.

OpenSearch автоматически создаёт индекс при добавлении документа, если индекс ещё не существует. Также, если ID не указан, OpenSearch сгенерирует его автоматически:

[source,console]
----
POST movies/\_doc
{ "title": "Spirited Away" }
----

Недостаток автоматической генерации ID — невозможность легко обновить документ позже. Если выполнить запрос 10 раз, будут созданы 10 разных документов. Чтобы указать ID вручную, используйте `PUT`:

[source,console]
----
PUT movies/\_doc/1
{ "title": "Spirited Away" }
----

Если отправить этот запрос 10 раз, документ останется один, а поле `_version` увеличится до 10.

По умолчанию индекс создаётся с одним primary-шардом и одной репликой. Чтобы задать другие параметры, создайте индекс заранее:

[source,console]
----

PUT more-movies
{
"settings": {
"number\_of\_shards": 6,
"number\_of\_replicas": 2
}
}
----

== Ограничения на имена индексов

* Только строчные буквы.
* Нельзя начинать с символов `_` или `-`.
* Нельзя использовать пробелы, запятые и следующие символы: `:`, `"`, `*`, `+`, `/`, `\`, `|`, `?`, `#`, `>`, `<`.

== Чтение данных

Для получения документа используйте `GET` по тому же пути, что и при индексации:

[source,console]
----
GET movies/\_doc/1
----

Пример ответа:

[source,json]
----
{
"\_index" : "movies",
"\_type" : "\_doc",
"\_id" : "1",
"\_version" : 1,
"\_seq\_no" : 0,
"\_primary\_term" : 1,
"found" : true,
"\_source" : {
"title" : "Spirited Away"
}
}
----

Если документ не найден, поле `found` будет `false`, а поле `_source` отсутствует.

Для получения нескольких документов используйте `_mget`:

[source,console]
----
GET \_mget
{
"docs": \[
{ "\_index": "<index>", "\_id": "<id>" },
{ "\_index": "<index>", "\_id": "<id>" }
]
}
----

Чтобы получить только определённые поля:

[source,console]
----
GET \_mget
{
"docs": \[
{ "\_index": "<index>", "\_id": "<id>", "\_source": "field1" },
{ "\_index": "<index>", "\_id": "<id>", "\_source": "field2" }
]
}
----

Для проверки наличия документа:

[source,console]
----
## HEAD movies/\_doc/<doc-id>
----

Если документ существует, вернётся код 200 OK, если нет — 404 Not Found.

== Обновление данных

Для частичного обновления полей используйте запрос `POST` к `_update` с изменениями в объекте `doc`:

[source,console]
----

POST movies/\_update/1
{
"doc": {
"title": "Castle in the Sky",
"genre": \["Animation", "Fantasy"]
}
}
----

Полученный документ будет:

[source,json]
----
{
"\_index" : "movies",
"\_type" : "\_doc",
"\_id" : "1",
"\_version" : 2,
"\_seq\_no" : 1,
"\_primary\_term" : 1,
"found" : true,
"\_source" : {
"title" : "Castle in the Sky",
"genre" : \["Animation", "Fantasy"]
}
}
----

Чтобы заменить документ полностью, используйте `PUT`:

[source,console]
----
PUT movies/\_doc/1
{ "title": "Spirited Away" }
----

Чтобы обновление выполнялось условно (если документ существует или нет), используйте параметр `upsert`:

[source,console]
----
POST movies/\_update/2
{
"doc": {
"title": "Castle in the Sky"
},
"upsert": {
"title": "Only Yesterday",
"genre": \["Animation", "Fantasy"],
"date": 1993
}
}
----

Пример ответа:

[source,json]
----
{
"\_index" : "movies",
"\_type" : "\_doc",
"\_id" : "2",
"\_version" : 2,
"result" : "updated",
"\_shards" : { "total" : 2, "successful" : 1, "failed" : 0 },
"\_seq\_no" : 3,
"\_primary\_term" : 1
}
----

Каждое обновление имеет уникальные значения `seq_no` и `primary_term`.

Чтобы избежать конфликта при параллельных изменениях документа, используйте optimistic concurrency control:

[source,console]
----
POST movies/\_update/2?if\_seq\_no=3\&if\_primary\_term=1
{
"doc": {
"title": "Castle in the Sky",
"genre": \["Animation", "Fantasy"]
}
}
----

Если с момента получения документа он был обновлён, значения `seq_no` и `primary_term` изменятся, и операция завершится ошибкой 409 Conflict.

При использовании `_bulk` указывайте `seq_no` и `primary_term` в метаданных действия.

== Удаление данных

Для удаления документа отправьте `DELETE`-запрос:

[source,console]
----
DELETE movies/\_doc/1
----
Поле `_version` увеличится. При повторной индексации с тем же ID версия продолжит увеличиваться, так как OpenSearch сохраняет метаданные документа даже после удаления.